#!/usr/bin/perl -w
#x3.out.filter=^be\.fedict\.eid\.ext\.middleware\.download\.linux\.([a-z0-9_-]+)\.(progress\.percentage|state|state\.comment)$

my $BASEURL = 'http://files.eid.belgium.be/';
my $DEBURL = "${BASEURL}debian/";
my $RPMURL = "${BASEURL}rpm/";
my $RESULTPREFIX='be.fedict.eid.ext.middleware.download.linux';

my @debrepos = ( 'wheezy', 'trusty', 'precise', 'qiana', 'maya' );
my %rpmrepos = (
	'fedora'	=> { vers => [ 19, 20 ], arch => [ 'i386', 'x86_64', '' ], gpg => 'n' },
	'epel'		=> { vers => [ 6 ], arch => ['i386', 'x86_64', '' ], gpg => 'n' },
	'opensuse'	=> { vers => [ 131 ], arch => [ '' ], gpg => 'y' },
);

my %states = ( OK => 0, WARNING => 1, ALERT => 2, MISSING => 3 );

use strict;
use warnings;

use LWP::UserAgent;
use XML::SAX;
use Digest::SHA qw(sha1_hex sha256_hex);
use IO::Uncompress::Gunzip;

package repomon::xmlparser;

sub characters {
	my ($self, $data) = @_;

	if(exists($self->{cdata})) {
		${$self->{cdata}} .= $data->{Data};
	}
}

sub new {
	my $class = shift;
	my $self = {};

	$self->{stanzas} = [];
	$self->{stanza} = {};
	$self->{stanzaname} = "";

	bless $self, $class;
}

sub start_element {
	my ($self, $el) = @_;
	my $stanza = $self->{stanza};

	if($el->{LocalName} eq "location") {
		$stanza->{location} = $el->{Attributes}{"{}href"}{Value};
	} elsif($el->{LocalName} eq "checksum") {
		my $key = "checksum-" . $el->{Attributes}{"{}type"}{Value};
		$stanza->{$key} = "";
		$self->{cdata} = \$stanza->{$key};
	}
}

sub end_element {
	my ($self, $el) = @_;

	if(exists($self->{cdata})) {
		delete $self->{cdata};
	}
	if($el->{LocalName} eq $self->{stanzaname}) {
		push @{$self->{stanzas}}, $self->{stanza};
		$self->{stanza} = {};
	}
}

sub getsizes {
	my $self = shift;
	my $retval = [];

	foreach my $stanza(@{$self->{stanzas}}) {
		push @$retval, $stanza->{size};
	}

	return $retval;
}

package repomon::mdparser;

our @ISA = "repomon::xmlparser";

sub new() {
	my $class = shift;

	my $self = $class->repomon::xmlparser::new($class);
	$self->{stanzaname} = "data";

	return $self;
}

sub start_element {
	my ($self, $el) = @_;
	my $stanza = $self->{stanza};

	$self->repomon::xmlparser::start_element($el);

	if($el->{LocalName} eq "size") {
		$stanza->{size} = "";
		$self->{cdata} = \$stanza->{size};
	} elsif($el->{LocalName} eq "data") {
		$stanza->{type} = $el->{Attributes}{"{}type"}{Value};
	}
}

package repomon::prparser;

our @ISA = "repomon::xmlparser";

sub new() {
	my $class = shift;

	my $self = $class->repomon::xmlparser::new($class);
	$self->{stanzaname} = "package";

	return $self;
}

sub start_element {
	my ($self, $el) = @_;
	my $stanza = $self->{stanza};

	$self->repomon::xmlparser::start_element($el);

	if($el->{LocalName} eq "size") {
		$stanza->{size} = $el->{Attributes}{"{}package"}{Value}
	}
}

package repomon::ua;
our @ISA = "LWP::UserAgent";

use Time::HiRes qw(gettimeofday tv_interval);

sub set_x3_sizes() {
	my $self = shift;
	my $sizes = shift;
	$self->{x3_sizes} = $sizes;
	my $total = 0;
	my $inc = [];
	foreach my $size(@$sizes) {
		push @$inc, $total;
		$total += $size;
	}
	$self->{x3_total_size} = $total;
	$self->{x3_inc_sizes} = $inc;
	$self->{x3_prev_st} = [0, 0];
}

sub set_x3_which() {
	my $self = shift;
	$self->{x3_which} = shift;
	$self->{x3_prev_st} = [0, 0];
}

sub set_x3_dist() {
	my $self = shift;
	$self->{x3_dist} = shift;
	$self->{x3_prev_st} = [0, 0];
}

sub progress() {
	my $self = shift;
	return unless defined($self->show_progress) && $self->show_progress > 0;
	return unless tv_interval($self->{x3_prev_st}) > .1;
	my $status = shift;
	my $request_or_response = shift;
	if($status eq "begin") {
		$status = 0;
	} elsif ($status eq "end") {
		$status = 1;
	}
	my $incsize = $self->{x3_inc_sizes}[$self->{x3_which}];
	my $fileloc = $self->{x3_sizes}[$self->{x3_which}] * $status;
	my $curloc = $incsize + $fileloc;
	$status = $curloc / $self->{x3_total_size};
	$status = int($status * 100);
	main::printresult($self->{x3_dist}, "progress.percentage", $status);
	$self->{x3_prev_st} = [gettimeofday()];
	print "\n";
}

package main;

my $ua = repomon::ua->new;
$ua->env_proxy;

sub printresult($$$) {
	my $dist = shift;
	my $sub = shift;
	my $value = shift;

	print "${RESULTPREFIX}.${dist}.${sub}=${value}\n";
}

sub parse_package_file($) {
	my $packages = shift;

	my $retval = [];
	my $currpkg = {};

	my $lastline = undef;
	foreach my $line (split /^/, $packages) {
		chomp $line;
		# Doesn't parse the Description: field correctly, but then
		# we're not here to check Description: fields, anyway
		if($line =~ /^ .+/) {
			# line continuation
			die "invalid Packages file"
				unless defined($lastline);
			$line =~ s/^ //;
			$lastline .= $line;
		} elsif($line =~ /^\s*$/) {
			# next stanza.
			next unless defined($lastline);
			my ($key, $value) = split /:/,$lastline,2;
			$value =~ s/^ //;
			$currpkg->{$key} = $value;
			push @$retval, $currpkg;
			$currpkg = {};
			# can't have continuation as first line
			# for a stanza, so undef lastline
			$lastline = undef;
		} else {
			# next key
			if(defined($lastline)) {
				my ($key, $value) = split /:/,$lastline,2;
				$value =~ s/^ //;
				$currpkg->{$key} = $value;
			}
			$lastline = $line;
		}
	}
	return $retval;
}

sub checkdeb() {
	foreach my $repo(@debrepos) {
		foreach my $arch('i386', 'amd64') {
			$ua->set_x3_dist("${repo}-${arch}");
			my $packurl = "${DEBURL}/dists/$repo/main/binary-$arch/Packages";
			print STDERR "Trying to get $packurl\n";
			my $req = HTTP::Request->new(GET => $packurl);
			my $res = $ua->request($req);
			if($res->is_success) {
				my $p_str = $res->decoded_content();
				my $parsed_repo = parse_package_file($p_str);
				my $comment = "";
				my $state = $states{OK};
				$ua->show_progress(1);
				my $sizes = [];
				foreach my $package(@$parsed_repo) {
					push @$sizes, $package->{"Size"};
				}
				$ua->set_x3_sizes($sizes);
				my $i = 0;
				foreach my $package(@$parsed_repo) {
					$ua->set_x3_which($i++);
					print STDERR "Package: " . $package->{"Package"} . ", version: " . $package->{"Version"} . "\n";
					my $fileurl = "${DEBURL}/" . $package->{Filename};
					my $sha1 = $package->{SHA1};
					my $freq = HTTP::Request->new(GET => "${fileurl}");
					printresult("${repo}-${arch}", "state.comment", "downloading ${fileurl}");
					my $fres = $ua->request($freq);
					if($fres->is_success) {
						my $digest = sha1_hex($fres->decoded_content());
						if($digest ne $sha1) {
							$state = $states{ALERT};
							$comment = "$fileurl has SHA1 $digest rather than expected SHA1 $sha1";
							last;
						}
					}
					$comment .= $package->{"Package"} . "_" . $package->{"Version"} . " ";
				}
				$ua->show_progress(0);
				printresult("${repo}-${arch}", "progress.percentage", "100");
				printresult("${repo}-${arch}", "state.comment", $comment);
				printresult("${repo}-${arch}", "state", $state);
			} else {
				printresult("${repo}-${arch}", "state", $states{ALERT});
			}
		}
	}

	# final newline to mention we're done for now.
	print "\n";
}

sub checkrpm() {
	foreach my $repo(keys %rpmrepos) {
		foreach my $vers(@{$rpmrepos{$repo}{vers}}) {
			foreach my $arch(@{$rpmrepos{$repo}{arch}}) {
				my $dasharch = "";
				if(length($arch) != 0) {
					$dasharch = "-${arch}";
				} 
				$ua->set_x3_dist("${repo}-${vers}${dasharch}");
				my $rpmbaseurl = "${RPMURL}/${repo}/${vers}/${arch}";
				my $mdurl = "${rpmbaseurl}/repodata/repomd.xml";
				my $req = HTTP::Request->new(GET => $mdurl);
				my $res = $ua->request($req);
				print STDERR $mdurl . "\n";
				my $comment = "";
				my $state = $states{OK};
				if($res->is_success) {
					my $md_str = $res->decoded_content();
					my $handler = repomon::mdparser->new();
					my $parser = XML::SAX::ParserFactory->parser(Handler => $handler);
					$parser->parse_string($md_str);
					my $sizes = $handler->getsizes();
					$ua->set_x3_sizes($sizes);
					$ua->show_progress(1);
					my $i = 0;
					my $primarydata;
					foreach my $stanza(@{$handler->{stanzas}}) {
						$ua->set_x3_which($i++);
						my $fileurl = "${rpmbaseurl}/" . $stanza->{location};
						my $freq = HTTP::Request->new(GET => $fileurl);
						printresult("${repo}-${vers}${dasharch}", "state.comment", "downloading $fileurl");
						my $fres = $ua->request($freq);
						if($fres->is_success) {
							my $sha256 = $stanza->{"checksum-sha256"};
							my $content = $fres->decoded_content();
							my $digest = sha256_hex($content);
							if($digest ne $sha256) {
								$state = $states{ALERT};
								$comment = "$fileurl has SHA256 $digest rather than expected SHA256 $sha256";
								last;
							}
							if($stanza->{"type"} eq "primary") {
								$primarydata = \$content;
							}
						}
						$comment .= $stanza->{location};
					}
					my $z = new IO::Uncompress::Gunzip($primarydata);
					my $prhandler = repomon::prparser->new();
					my $prparser = XML::SAX::ParserFactory->parser(Handler => $prhandler);
					$prparser->parse_file($z);
					push @$sizes, @{$prhandler->getsizes()};
					$ua->set_x3_sizes($sizes);
					foreach my $stanza(@{$prhandler->{stanzas}}) {
						$ua->set_x3_which($i++);
						my $fileurl = "${rpmbaseurl}/" . $stanza->{location};
						my $freq = HTTP::Request->new(GET => $fileurl);
						printresult("${repo}-${vers}${dasharch}", "state.comment", "downloading $fileurl");
						my $fres = $ua->request($freq);
						if($fres->is_success) {
							my $sha256 = $stanza->{"checksum-sha256"};
							my $content = $fres->decoded_content();
							my $digest = sha256_hex($content);
							if($digest ne $sha256) {
								$state = $states{ALERT};
								$comment = "$fileurl has SHA256 $digest rather than expected SHA256 $sha256";
								last;
							}
						}
						# TODO: GPG verification
					}
				} else {
					$comment = "failed to download $mdurl";
					$state = $states{ALERT};
				}
				printresult("${repo}-${vers}${dasharch}", "progress.percentage", "100");
				printresult("${repo}-${vers}${dasharch}", "state", $state);
				printresult("${repo}-${vers}${dasharch}", "state.comment", $comment);
			}
		}
	}
}

sub repomon() {
    while(1) {
        checkdeb;
        sleep 5;
        checkrpm;
        sleep 5;
    }
}

repomon;
